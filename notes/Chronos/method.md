# 框架
由于一个程序的执行时间取决于输入数据（决定程序执行路径）和处理器（影响指令执行时间），静态 WCET 分析通常被分为以下三个步骤：

* 程序路径分析
* 微处理器架构建模
* WCET 计算

## 程序路径分析
可以从源码或者编译之后的代码或者两者获得程序流信息，例如可达/不可达执行路径。不可达路径在搜索最坏情况下路径/执行时间时是需要被忽略的。

## 微处理器架构建模
这与指令时间有关，现代处理器具有一些加速特性，如流水线、cache和分支预测，来改善程序的性能。这些特性使得单条指令的执行时间不恒定（例如，一条指令在 cache miss 的情况下执行时间远远大于在 cache 命中的情况下执行时间），依赖于执行的历史。微处理器架构建模就是利用静态技术研究这些特性的行为，为决定程序执行时间提供指令执行时间的信息（如cache miss 发生的次数等）。

## WCET 计算
在上述提及的子任务中，获得了程序路径和执行时间信息，在某条路径上程序的执行时间就可以评估出来，选择其中一个最大的最为最终的 WCET 结果。

# 工作流图
![](http://www.comp.nus.edu.sg/~rpembed/chronos/images/flow.png)

我们利用 [SimpleScalar](http://www.simplescalar.com/) 工具集来编译和仿真程序，用 SimpleScalar *sim-outorder* 仿真器建立一个简单的处理器模型。假设需要分析的源码名为 <benchmark>.c ，我们工具工作如下：

1. 首先，\<benchmark\>.c 用 SimpleScalar 自带的 GCC 编译成二进制代码 \<benchmark\> 。这个 GCC 版本编译出的代码是 MIPS 指令集的。
2. 我们的工具读入二进制代码，为 \<benchmark\> 中函数重建程序控制流图（CFG）。CFG 会和源程序在同一个目录下保存名为 \<benchmark\>。程序流路径可以表示成线性的限制，我们称为"流限制"（Flow Constraints）。另外，我们工具允许用户通过一个图形化的接口输入一些限制，如循环的上界和一些其它的流事实（Flow Facts），这些限制成为"用户限制"(User Constraints)。这一步对应的是之前介绍的程序路径分析（图中 "PA" 表示的是 Path Analysis）。
3. 基于处理器模型，这个可以由用户通过图形化界面配置出来，我们工具可以对微处理器架构建模，(1) 根据执行上下文得到基本块的时间信息；(2) 执行上下文出现的限制（指令cache 的状态、分支预测信息等）。结合流限制和用户限制，我们工具就构造了一个完整的整数线性规划（Integer Linear Programming, ILP）问题，对应的输出文件为 \<benchmark\>.lp。
4. 工具再触发一个高性能商业 ILP 解决器 CPLEX，或者一个自由的 ILP 解决器 lp_solve 来解 ILP 问题，得到结果就是评测的 WCET（**estimated WCET**)。
5. 使用与评测相同的处理器配置，除了得到评测的WCET，通过 SimpleScalar 工具集中的 simoutdoor 仿真器还可以得到观察的WCET（**observed WCET**）。

