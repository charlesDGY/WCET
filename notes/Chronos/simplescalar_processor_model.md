# SimpleScalar 处理器模型

我们首先描述 SimpleScalar 处理器模型，指出什么特性已经建模了，什么还没有建模，什么是有限制的建模。

图1 是 SimpleScalar 乱序仿真器包含的主要处理器模型的组件，注意分支预测器没有在这个图上显示出来，流水线包括以下五个阶段：

1. **指令预取（IF）**  在这个阶段，指令序列从指令 cache 或者内存中取到多入口的 buffer 中，称之为*分派队列*（dispath queue）。指令取出的条数依赖于以下因素：（1）处理器预取宽度；（2）分派队列的可用入口；（3）cache 行的大小，是否发生 cache miss，以及位置。这些参数，大多在下一个阶段会提到，可以在运行时配置。注意，取指令的位置是由程序计数器和分支预测器所决定的。

2. **指令译码（ID）**  在这一阶段，在分派队列中的指令被译码放入另一个 buffer 中，称之为 RUU（Register Update Unit），这个部件的功能是作为寄存器重命名单元和指令重排 buffer。译码的指令条数由以下因素决定：（1）译码宽度；（2）在分派队列和 RUU 中可用的入口。这一阶段，调度器会分析数据依赖，决定哪条指令可以执行，将其放入*就绪队列*(ready queue)中。

3. **指令执行（EX）** 在这一阶段，就绪队列贯穿全部，在队列中的指令如果相应的功能部件可用的情况，就发射执行。除了就绪队列的指令条数和可用的功能部件，发射的指令条数也受发射宽度所限。对于 load 和 store 类指令，这阶段完成内存寻址，实际的读写操作要在写回和提交阶段来完成。注意，指令在这一阶段可以乱序执行，例如迟来的指令操作数就绪、功能部件可用，可以比那些还在等其操作数的先到来的指令先执行。

4. **写回（WB）**  这阶段，load 指令将在 EX 阶段已计算好的地址内容写到存储层次中，这可能涉及到 L1 数据 cache，TLB，L2 数据 cache 以及主存，依赖于存储层次如何配置的。已加载的数据前往 RUU 中有依赖关系的指令中，如果等待的指令的所有操作数都就绪之后，指令就被调度器放入就绪队列中。这一阶段，ALU 操作的结果会被写回到寄存器中。分支结果也在这一阶段被计算出来，如果分支预测错误的话流水器被刷新。

5. **提交（CM）**  这是最后一阶段，已完成执行的指令以程序的顺序进行提交。这意味着，如果最早到来的指令没有完成的话，就没有指令会被提交。提交指令的条数与之前阶段相似，受提交宽度所限制。

更多 SimpleScalar 体系结构的细节，可以参考其用户手册。在这一版本，我们的处理器模型有一下简化的 SimpleScalar 体系特性：

* **处理器核** 我们没有对写回宽度进行建模，比如在写回阶段，在前一个时钟周期的 EX 阶段产生结果的每一条指令，都会被写回到寄存器中。
* **内存层次** 数据 cache 没有被建模，每个 load 操作都假设在单个时钟周期内完成；TLB 没有被建模，我们假设虚拟地址与物理地址相同；只有一级指令 cache 被建模了。
* **分支预测** 在这一版本，不是所有 SimpleScalar 支持的分支预测器都被建模。主要支持以下几种：完美预测，每个分支都假设正确地被预测；两级预测，包括 gshare、GAg 和本地预测。这些二级预测可以由一组参数统一说明。一个简化的分支预测是仅仅只有一位，而不是普遍的两位计数，在每次预测表项中使用和更新。另外，我们假设一个完美的分支目标缓存（Branch Target Buffer, BTB），分支目标地址在 IF 阶段有用。

























